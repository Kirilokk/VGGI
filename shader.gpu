
// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex;
attribute vec3 normal;
uniform mat4 ModelViewProjectionMatrix;
uniform mat4 worldInverseTranspose;
uniform vec3 lightWorldPosition;
varying vec3 v_normal; 
varying vec3 lightPosition;
varying vec3 vertexPos;
void main() {
    vec4 vertexPosition4 = ModelViewProjectionMatrix * vec4(vertex, 1.0);
    vec4 lightPosition4 = ModelViewProjectionMatrix * vec4(lightWorldPosition, 1.0);
    lightPosition = vec3(lightPosition4) / lightPosition4.w;
    v_normal = mat3(worldInverseTranspose) * normal;
    vertexPos = vec3(vertexPosition4) / vertexPosition4.w;
    
    gl_Position = vertexPosition4;
}`;


// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif


varying vec3 v_normal;
varying vec3 lightPosition;
varying vec3 vertexPos;
void main() {
    vec3 AmbientLight   = vec3(1.0,0.0,0.0);
    vec3 DiffuseLight   = vec3(1.0,1.0,1.0);
    vec3 SpecularLight  = vec3(1.0,1.0,1.0);
    vec3 AmbientModel   = vec3(0.4,0.1,0.1);
    vec3 DiffuseModel   = vec3(0.1,0.1,0.1);
    vec3 SpecularModel  = vec3(0.1,0.1,0.1);

    vec3 normal = normalize(vec3(v_normal)); 
    vec3 Light = normalize(lightPosition);


    float LightPoint = max(dot(normal, Light), 0.0); 
    float shininess = 70.0;
    float specular = 0.5;

    // Reflected light vector
    vec3 R = reflect(-Light, normal);
    // Vector to viewer
    vec3 viewPoint = normalize(-vertexPos);

    float specAngle = max(dot(R, viewPoint), 0.0);
    specular = pow(specAngle, shininess);


    gl_FragColor = vec4(AmbientLight * AmbientModel +
                      DiffuseLight * LightPoint * DiffuseModel +
                      SpecularLight * specular * SpecularModel, 1.0);


}`;